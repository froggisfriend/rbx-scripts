if not MTAPIMutex then loadstring([=[local a=MTAPIMutex if a then return end local d=table local u=type local v=assert local i=game local e=error local c=string local b=getgenv local j=checkcaller local a=getnamecallmethod local l=hookmetamethod local k=newcclosure local c=c.format local s,q,r,m,n,o,t,p={},{},{},{},{},{},{},{}local g,f,h g=l(i,"__index",k(function(b,a)if not j()then if s[b]and s[b][a]then local a=s[b][a]return a.IsCallback and a.Value(b)or a.Value end if m[a]then local a=m[a]return a.IsCallback and a.Value(b)or a.Value end if t[b]and t[b][a]then return p[b][a]end end return g(b,a)end))f=l(i,"__newindex",k(function(h,g,d)if not j()then if q[h]and q[h][g]then local a=q[h][g]return a.Callback and a.Callback(h,d)or nil end if n[g]then local a=n[g]return a.Callback and a.Callback(h,d)or nil end if t[h]and t[h][g]then local a=u(d)local b=t[h][g]if a~=b["Type"]then e(c([[bad argument #3 to '%s' ("%s" expected, got %s)]],g,b["Type"],a),2)end p[h][g]=d return end end return f(h,g,d)end))h=l(i,"__namecall",k(function(e,...)local b=a()if j()then local d=d.pack(...)if b=="AddGetHook"then v(#d>0,"mt-api: Invalid argument count")local c=d[1]local b=d[2]local a=d[3]v(u(c)=="string","mt-api: Invalid hook type")s[e]=s[e]or{}if a then v(u(b)=="function","mt-api: Invalid callback function")end s[e][c]={Value=b,IsCallback=a}local a=function()s[e][c]=nil end return{remove=a,Remove=a}elseif b=="AddGlobalGetHook"then local c=d[1]local a=d[2]local b=d[3]v(u(c)=="string","mt-api: Invalid hook type")if b then v(u(a)=="function","mt-api: Invalid callback function")end m[c]={Value=a,IsCallback=b}local a=function()m[c]=nil end return{remove=a,Remove=a}elseif b=="AddSetHook"then v(#d>0,"mt-api: Invalid argument count")local b=d[1]local a=d[2]v(u(b)=="string","mt-api: Invalid hook type")q[e]=q[e]or{}q[e][b]={Callback=u(a)=="function"and a or nil}local a=function()q[e][b]=nil end return{remove=a,Remove=a}elseif b=="AddGlobalSetHook"then v(#d>0,"mt-api: Invalid argument count")local b=d[1]local a=d[2]v(u(b)=="string","mt-api: Invalid hook type")n[b]={Callback=u(a)=="function"and a or nil}local a=function()n[b]=nil end return{remove=a,Remove=a}elseif b=="AddCallHook"then v(#d>1,"mt-api: Invalid argument count")local b=d[1]local a=d[2]v(u(b)=="string","mt-api: Invalid hook type")v(u(a)=="function","mt-api: Invalid argument #2 (not function)")r[e]=r[e]or{}r[e][b]={Callback=a}local a=function()r[e][b]=nil end return{remove=a,Remove=a}elseif b=="AddGlobalCallHook"then v(#d>1,"mt-api: Invalid argument count")local b=d[1]local a=d[2]v(u(b)=="string","mt-api: Invalid hook type")v(u(a)=="function","mt-api: Invalid argument #2 (not function)")o[b]={Callback=a}local a=function()o[b]=nil end return{remove=a,Remove=a}elseif b=="AddPropertyEmulator"then v(#d>0,"mt-api: Invalid argument count")local b=d[1]v(u(b)=="string","mt-api: Invalid hook type")local a=e[b]t[e]=t[e]or{}p[e]=p[e]or{}t[e][b]={Type=u(a)}p[e][b]=a local a=function()t[e][b]=nil p[e][b]=nil end return{remove=a,Remove=a}end return h(e,...)end if r[e]and r[e][b]then local a=r[e][b]return a["Callback"](e[b],...)end if o[b]then local a=o[b]return a["Callback"](e,e[b],...)end return h(e,...)end))b().MTAPIMutex=true]=])() end